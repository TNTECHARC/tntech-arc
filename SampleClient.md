# A Sample Client's Code #
**Let's show some code and then explain it afterwards. I will try to keep this article up to date with any changes.**
```
#include "network/client_bsd.h"  //The client connection class
#include "messages/message_ids.h"//Used for message prefs.
#include "messages/sensors.pb.h" //Used for LaserScan msg.
#include <iostream>
#include <string>

//#########################################################
//Author: Daniel Oliver.
//Last modified: September 14, 2013.
//Purpose: To illustrate a sample client which pulls LIDAR
//   data from the server and performs basic operations on
//   the data.
//#########################################################

//This function is called by the client class whenever data is received from the server
bool callback( std::string packet, int msg_type, int unique_id );

//Accepts command line parameters.
int main( int argc, char* argv[] )
{
  //The client constructor asks for a callback function.
  //We give it the address of the above function "callback".
  asimov::ClientBSD client( &callback );
  //The client will ask the server for this kind of message.
  client.add_message_pref( asimov::msg_LaserScan_ID );
  //This client is informally identified by this name:
  client.set_name( "Obstacle avoidance" );
  //Read user input from STD::CIN
  client.ReadFromCIN( true );

  std::string address = "127.0.0.1";
  if( argc > 1 ) //Checks if there is any command line parameters.
    address = std::string( argv[1] ); //Override the default address.

  char answer;
  do
  { //Attempt to connect to the server as many times as the user wants to.
    if( client.Connect( address ) )
    { //If successful connection to server...
      while( client.is_connected() )
      { //... listen until the connection is broken.
        client.Listen();
      }
    }
    //A standard CSC-2100 prompt.
    std::cout << "Try to connect again?  (y)es or (n)o?   ";
    std::cin >> answer;
  }
  while( answer == 'y' );
  return 0;
}
//Global Variable declarations.
asimov::msg_LaserScan lidar_scan; //Used by callback functions. Static variable on stack.

//This function is called by the client class whenever data is received from the server
bool callback( std::string packet, int msg_type, int unique_id )
{ //Check for msg type.
  if( msg_type == asimov::msg_LaserScan_ID )
  { //Another error check to make sure message packet is valid as well as actual Parsing.
    if( lidar_scan.ParseFromString( packet ) )
    { float radian_least = 3.14159 / 2.0; //Straight ahead
      float radian_most  = 3.14159 / 2.0; //Straight ahead
      for( int i = 0; i < lidar_scan.angles_size(); i++ )
      { //Record the least/greatest angle
        radian_least = std::min( radian_least, lidar_scan.angles( i ) );
        radian_most  = std::max( radian_most,  lidar_scan.angles( i ) );
      }
      //Display the least/greatest angle in this scan.
      std::cout << "Greatest angle = " << radian_most << "     Least angle = " << radian_least << "\n";
    }
  }
  return true;
}
```

# Explanation #
The first thing to note is the local file includes which are assumed to be relative to the directory "tntech-arc/asimov/". The first include is the actual client class. The second is the list of message identifiers such as "asimov::msg\_LaserScan\_ID". The third is the sensor classes generated by Google Protocol Buffers such as "asimov::msg\_LaserScan".
```
#include "network/client_bsd.h"  //The client connection class
#include "messages/message_ids.h"//Used for message prefs.
#include "messages/sensors.pb.h" //Used for LaserScan msg.
```

This callback function is the entry point for an event-driven system where this function is called when there is a new message received from the server.
```
//This function is called by the client class whenever data is received from the server
bool callback( std::string packet, int msg_type, int unique_id );
```
Which matches this function defined by the client-server system. Don't bother remembering this, just remember that the callback function does have a format.
```
//(message, msg type, uid of sender)
typedef std::function<bool( std::string, int, int )> client_callback;
```
### Main function ###
Now lets enter the main function, the true starting point of this module.
```
  asimov::ClientBSD client( &callback );
```
This initializes the Client class along with one parameter, the address of the above defined callback function to use.
```
  client.add_message_pref( asimov::msg_LaserScan_ID );
```
All the message identifiers are listed in "messages/message\_ids.h" as well as the corresponding Python file.
```
  client.set_name( "Obstacle avoidance" );
```
Doesn't really need an explanation. Just a name given to the server for easy identification of connections.
```
  client.ReadFromCIN( true );
```
Remember cin and cout? The client will read the user's input and there are several commands such as "echo some\_message" that the client will respond to.
```
  std::string address = "127.0.0.1";
  if( argc > 1 ) //Checks if there is any command line parameters.
    address = std::string( argv[1] ); //Override the default address.
```
"address" is just an IP version 4 address. Hopefully the input is the correct IP address of the server.
```
    if( client.Connect( address ) )
```
Tells the client to actually complete the connection. Returns true if successful.
```
      while( client.is_connected() )
      { client.Listen();
      }
```
While the connection is unbroken, listen to the server.
### The global variables ###
```
asimov::msg_LaserScan lidar_scan;
```
This is a generated Protocol Buffer class which is declared statically for efficiencyâ€™s sake but used by the callback function. If you want to see its functions look in "messages/sensors.pb.h" which comes from the definitions in "messages/sensors.proto".

### The Callback function ###
A callback function is a term thrown about a lot, concisely it is "a function passed to an API to be called at a later time". In this instance, the API is the Client-Server system and the 'later time' is the event of received data. Since this function's prototype has already been declared, lets just examine its contents.
```
bool callback( std::string packet, int msg_type, int unique_id )
{ //Check for msg type.
  if( msg_type == asimov::msg_LaserScan_ID )
```
If a client requests multiple message types then it becomes an if-else statement to accommodate each type.
```
    if( lidar_scan.ParseFromString( packet ) )
```
This does two things, makes sure the data packet is valid and translates it from message binary format to this computer's binary format. Parsing a message is extremely fast with negligible overhead. Now all the data is accessible via the interface defined in "messages/sensors.pb.h" which comes from the definitions in "messages/sensors.proto".
```
      float radian_least = 3.14159 / 2.0; //Straight ahead
      float radian_most  = 3.14159 / 2.0; //Straight ahead
      for( int i = 0; i < lidar_scan.angles_size(); i++ )
      { //Record the least/greatest angle
        radian_least = std::min( radian_least, lidar_scan.angles( i ) );
        radian_most  = std::max( radian_most,  lidar_scan.angles( i ) );
      }
      //Display the least/greatest angle in this scan.
      std::cout << "Greatest angle = " << radian_most << "     Least angle = " << radian_least << "\n";
```
This finds the greatest and least angle values. Do note the use of "std::max" and "std::min" to simplify the search through the angle values. The moral: if there is a std function for something then use it. Since "angles" is an array, access its contents by the use of an index as shown above. Also, there is the size function to determine the array bounds. This is where data manipulation on new sensor data takes place. Just replace this area with your own functions and you have easy access to Lidar data.

## Summary ##
The functions outlined in this article may change as the system evolves, so do be aware of that. This is by no means comprehensive and is just a starting point.

//Last modified September 14th, 2013. By Daniel Oliver